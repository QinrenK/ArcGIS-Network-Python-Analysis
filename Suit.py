# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------

# Purpose: Mult-Criteria / Multi-Objective Land Allocation

# Author: Github q5kang
# Created on: 2019-02-14 12:31:36.00000
#   (generated by ArcGIS/ModelBuilder)
# Description: 
# Four main processes are iterated in this document including suitAg, suitDev, suitNat and 1b processes.
# suitAg produces a suitability map based on Agricultural criteria, where suitDev and suitNat produce suitability
# maps with their criteria. 1b produces the future land availability map based on highest score of three factors.
# Conflict map produces a map demonstrates different pixel value conflict and shows the trend of conflict levels.

# precondition: input raster have to be of numeric type
#               rasters must remain the same spatial extent, same resolution, same number of rows and columns
# postcondition: output raster may have a new range of values therefore maybe rendered slightly differents

# Import arcpy module
import arcpy
import time
import numpy
startTime = time.time()
arcpy.env.overwriteOutput = True
arcpy.CheckOutExtension("Spatial")

# Local variables:

# neaa: Ann Arbor City Limits
# neclayp: percent clay in soils
# nedem: digiral elevation model
# nelu95: 1995 land use
# landuse_legend.dbf: Text descriptions of land use codes
# nepreset: Presettlement vegetation
# nepublic: Public land areas
# neroadsL: Roads and railroads
# nesandp: percent sand in soils
# nestream: Rivers, streams, lakes and ponds

# var for suitAg
nestream = "C:\\Users\\q5kang"


# var for suitDev
neroads = "C:\\Users\\q5kang\\"

# var for suitNat
nelu95__2_ = "C:\\Users\\q5kang"


#Local variables for 1b
nelu95__2_ = "C:\\Users\\q5kang"



# whole processes start

# suitNat starts

# Process: Euclidean Distance (2)
# Input: nestream
# Output: Agr_Dis_stream
# Function: get the ecuclidean distance of the nestream based on cell size 30.
arcpy.gp.EucDistance_sa(nestream, Agr_Dis_stream, "", "30")

# Process: Euclidean Distance (4)
# Input nesandp
# Output: EucDist_Clay
# Function: get the ecuclidean distance of the nestream based on cell size 30.
arcpy.gp.EucDistance_sa(nesandp, EucDist_Clay, "", "30")

# Process: Reclassify
# Input; value of nelu95
# Output: reclass_nelu1
# Function: reclassify nelu95 raster based on its value property
arcpy.Reclassify_3d(nelu95, "VALUE", "111 194 0;194 429 1;429 740 0", Reclass_nelu1, "DATA")

# Process: Slope
# Input: nedem
# Output: Agr_slope
# Function: bsaed on degree, calculate the slope of nedem
arcpy.gp.Slope_sa(nedem, Agr_slope, "DEGREE", "0.3048", "PLANAR", "METER")

# Process: Slice (3)
# Input: Agr_slope
# Output: Agr_slope_slice
# Function: bsaed on equal interval method, slice the agriculture slope to 100 pieces.
arcpy.gp.Slice_sa(Agr_slope, Agr_slope_slice, "100", "EQUAL_INTERVAL", "1")

# Process: Minus
# Input: Input_raster_or_constant_value_1, Agr_slope_slice
# Output: Agr_minus_slope
# Function: Use Num 101 to get the - effect of the slope variable
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1, Agr_slope_slice, Agr_minus_slope)

# Process: Slice (2)
# Input: Agr_Dis_stream
# Output: Agr_slice_stream
# Function: Sliced the stream distance to 100 piece based on equal interval
arcpy.gp.Slice_sa(Agr_Dis_stream, Agr_slice_stream, "100", "EQUAL_INTERVAL", "1")

# Process: Slice (4)
# Input EucDist_Clay
# Output: Slice_clay
# Function: Sliced the clay to 100 piece based on equal interval
arcpy.gp.Slice_sa(EucDist_Clay, Slice_clay, "100", "EQUAL_INTERVAL", "1")

# Process: Minus (2)
# Input: Input_raster_or_constant_value_1__2_, Slice_clay
# Output: Minus_clay
# Function: Use Num 101 to get the - effect of the clay variable
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1__2_, Slice_clay, Minus_clay)

# Process: Reclassify (4)
# Input; value of nelu95__2_
# Output: Agr_95dev
# Function: reclassify nelu95__2_ raster based on its value property
arcpy.gp.Reclassify_sa(nelu95__2_, "VALUE", "111 194 1;194 625 0", Agr_95dev, "DATA")

# Process: Euclidean Distance (3)
# Input Agr_95dev
# Output: Euc_Agr
# Function: get the ecuclidean distance of the Agr_95dev based on cell size 30.
arcpy.gp.EucDistance_sa(Agr_95dev, Euc_Agr, "", "30")

# Process: Slice (6)
# Input Euc_Agr
# Output: Agr_95dev_slice
# Function: Sliced the Euc_Agr to 100 piece based on equal interval
arcpy.gp.Slice_sa(Euc_Agr, Agr_95dev_slice, "100", "EQUAL_INTERVAL", "1")

# Process: Weighted Sum
# Input: Agr_slice_stream, Agr_minus_slope, Minus_clay, Agr_95dev_slice
# Output: AHP_Agr
# Function: weight four criteria in different weight
arcpy.gp.WeightedSum_sa("'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\ag.gdb\\Agr_minus_slope' VALUE 0.59;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\ag.gdb\\Agr_slice_stream' VALUE 0.13;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\ag.gdb\\Minus_clay' VALUE 0.2;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\ag.gdb\\Agr_95dev_slice' VALUE 0.08", AHP_Agr)

# Process: Times
# Input: Reclass_nelu1, AHP_Agr
# Output: SuitAgr
# Function: Times the values after weighted and the reclassified map
arcpy.gp.Times_sa(Reclass_nelu1, AHP_Agr, SuitAgr)

# Process: Slice (5)
# Input SuitAgr
# Output: SuitSliceAgr
# Function: Sliced the SuitAgr distance to 100 piece based on equal area method 
arcpy.gp.Slice_sa(SuitAgr, SuitSliceAgr, "100", "EQUAL_AREA", "1")

# suitNat ends



# suitDev starts

# Process: Reclassify
# Input; value of neroads
# Output: Plannable_Roads
# Function: reclassify neroads raster based on its value property
arcpy.gp.Reclassify_sa(neroads, "VALUE", "2 0;3 0;4 0;9 0;18 0", Plannable_Roads, "DATA")

# Process: Euclidean Distance
# Input: Plannable_Roads
# Output: road_distance
# Function: get the ecuclidean distance of the Plannable_Roads based on cell size 30.
arcpy.gp.EucDistance_sa(Plannable_Roads, road_distance, "", "30")

# Process: Reclassify (2)
# Input; value of nestream
# Output: re_stream
# Function: reclassify nestream raster based on its value property
arcpy.gp.Reclassify_sa(nestream, "VALUE", "6 0;7 0;8 0", re_stream, "DATA")

# Process: Euclidean Distance (2)
# Input: re_stream
# Output: stream_dis
# Function: get the ecuclidean distance of the re_stream based on cell size 30.
arcpy.gp.EucDistance_sa(re_stream, stream_dis, "", "30")

# Process: Reclassify (3)
# Input; value of neaa
# Output: A_reclass
# Function: reclassify neaa raster based on its value property
arcpy.gp.Reclassify_sa(neaa, "VALUE", "0 NODATA;1 1", A_reclass, "DATA")

# Process: Euclidean Distance (4)
# Input: A_reclass
# Output: A_dist
# Function: get the ecuclidean distance of the A_reclass based on cell size 30.
arcpy.gp.EucDistance_sa(A_reclass, A_dist, "", "30")

# Process: Slope
# Input: nedem
# Output: slope__2_
# Function: bsaed on degree, calculate the slope of nedem
arcpy.gp.Slope_sa(nedem, slope__2_, "DEGREE", "0.3048", "PLANAR", "METER")

# Process: Slice (3)
# Input: slope__3_
# Output: slice_slope
# Function: bsaed on equal interval method, slice the slope__3_ to 100 pieces.
arcpy.gp.Slice_sa(slope__3_, slice_slope, "100", "EQUAL_INTERVAL", "1")

# Process: Minus
# Input: Input_raster_or_constant_value_1, slice_slope
# Output: minus_slope
# Function: Use Num 101 to get the - effect of the slope variable
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1, slice_slope, minus_slope)

# Process: Slice (2)
# Input: stream_dis
# Output: stream_slice
# Function: bsaed on equal interval method, slice the stream_dis to 100 pieces.
arcpy.gp.Slice_sa(stream_dis, stream_slice, "100", "EQUAL_INTERVAL", "1")

# Process: Slice (4)
# Input: A_dist
# Output: A_slice
# Function: bsaed on equal interval method, slice the A_dist to 100 pieces.
arcpy.gp.Slice_sa(A_dist, A_slice, "100", "EQUAL_INTERVAL", "1")

# Process: Minus (2)
# Input: Input_raster_or_constant_value_1__2_, A_slice
# Output: minus_aa
# Function: Use Num 101 to get the - effect scores
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1__2_, A_slice, minus_aa)

# Process: Slice
# Input: road_distance
# Output: road_sli
# Function: bsaed on equal interval method, slice the road_distance to 100 pieces.
arcpy.gp.Slice_sa(road_distance, road_sli, "100", "EQUAL_INTERVAL", "1")

# Process: Minus (3)
# Input: Input_raster_or_constant_value_1__3_, road_sli
# Output: minus_roads
# Function: Use Num 101 to get the - effect scores of roads
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1__3_, road_sli, minus_roads)

# Process: Weighted Sum
# Input: minus_slope, stream_slice, minus_roads, minus_aa
# Output: AHP_Agr
# Function: weight four criteria in different weight
arcpy.gp.WeightedSum_sa("'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\Gan geog 381\\geog 381\\geog381\\A1_MCE\\A1_MCE\\minus_slope' VALUE 0.07;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\Dev.gdb\\stream_slice' VALUE 0.49;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\Dev.gdb\\minus_aa' VALUE 0.16;'C:\\Users\\q5kang\\OneDrive - University of Waterloo\\381A2\\Dev.gdb\\minus_roads' VALUE 0.28", AHP)

# Process: Reclassify (4)
# Input; value of nelu95
# Output: reclassify_dev95
# Function: reclassify nelu95 raster based on its value property
arcpy.Reclassify_3d(nelu95, "VALUE", "111 194 0;194 429 1;429 625 0", reclassify_dev95, "DATA")

# Process: Times
# Input: AHP, reclassify_dev95
# Output: suitDev
# Function: Times the values after weighted and the reclassified map
arcpy.gp.Times_sa(AHP, reclassify_dev95, suitDev)

# Process: Slice (5)
# Input: suitDev
# Output: Dev_slice
# Function: bsaed on equal area method, slice the suitDev to 100 pieces.
arcpy.gp.Slice_sa(suitDev, Dev_slice, "100", "EQUAL_AREA", "1")

# suitDev ends



# suitNat starts

# Process: Reclassify (3)
# Input: value of nelu95__2_
# Output: Reclass_wetland
# Function: reclassify nelu95__2_ raster based on its value property
# requirement: input must be a raster data type
arcpy.gp.Reclassify_sa(nelu95__2_, "VALUE", "111 530 NODATA;530 625 1", Reclass_wetland, "DATA")

# Process: Raster to Polygon
# Input: Reclass_wetland
# Output: R2T_nelu95b
# Function: simply transfer raster data to vector polygon
arcpy.RasterToPolygon_conversion(Reclass_wetland, R2T_nelu95b, "SIMPLIFY", "VALUE", "SINGLE_OUTER_PART", "")

# Process: Euclidean Distance (2)
# Input: R2T_nelu95b
# Output: EucDist_R2T_wetland
# Function: get the ecuclidean distance of the A_reclass
arcpy.gp.EucDistance_sa(R2T_nelu95b, EucDist_R2T_wetland, "", "73.08")

# Process: Euclidean Distance (3)
# Input: nestream
# Output: EucDist_stream
# Function: get the ecuclidean distance of the re_stream based on cell size 30.
arcpy.gp.EucDistance_sa(nestream, EucDist_stream, "", "30")

# Process: Euclidean Distance (4)
# Input: nepreset
# Output: EucDist_vege
# Function: get the ecuclidean distance of the re_stream based on cell size 30.
arcpy.gp.EucDistance_sa(nepreset, EucDist_vege, "", "30")

# Process: Reclassify
# Input; value of nelu95
# Output: Reclass_nelu_nowater
# Function: reclassify nelu95 raster to avoid unavailable land
arcpy.Reclassify_3d(nelu95, "VALUE", "111 0;112 1;113 2;115 3;121 4;122 5;124 6;126 7;128 8;131 9;134 10;138 11;141 12;142 13;144 14;145 15;146 16;171 17;172 18;193 19;194 20;210 21;220 22;230 23;240 24;250 25;290 26;310 27;320 28;412 29;421 30;429 31;510 32;520 33;530 34;611 35;613 36;622 37;625 38", Reclass_nelu_nowater, "DATA")

# Process: Slope
# Input: nedem
# Output: Slope_dem
# Function: bsaed on degree, calculate the slope of nedem
arcpy.gp.Slope_sa(nedem, Slope_dem, "DEGREE", "1", "PLANAR", "METER")

# Process: Slice
# Input: Slope_dem
# Output: Slice_Slope
# Function: bsaed on equal interval method, slice the suitDev to 100 pieces.
arcpy.gp.Slice_sa(Slope_dem, Slice_Slope, "100", "EQUAL_INTERVAL", "1")

# Process: Slice (3)
# Input: EucDist_vege
# Output: Slice_vege
# Function: bsaed on equal interval method, slice the suitDev to 100 pieces.
arcpy.gp.Slice_sa(EucDist_vege, Slice_vege, "100", "EQUAL_INTERVAL", "1")

# Process: Slice (4)
# Input: EucDist_stream
# Output: Slice_stream
# Function: bsaed on equal interval method, slice the suitDev to 100 pieces.
arcpy.gp.Slice_sa(EucDist_stream, Slice_stream, "100", "EQUAL_INTERVAL", "1")

# Process: Minus
# Input: Input_raster_or_constant_value_1, Slice_stream
# Output: Minus_stream
# Function: Use Num 101 to get the - effect scores of stream
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1, Slice_stream, Minus_stream)

# Process: Slice (2)
# Input: EucDist_R2T_wetland
# Output: Slice_wetland
# Function: bsaed on equal interval method, slice the suitDev to 100 pieces.
arcpy.gp.Slice_sa(EucDist_R2T_wetland, Slice_wetland, "100", "EQUAL_INTERVAL", "1")

# Process: Minus (2)
# Input: Input_raster_or_constant_value_1__2_, Slice_wetland
# Output: Minus_wetland
# Function: Use Num 101 to get the - effect scores of wetland
arcpy.gp.Minus_sa(Input_raster_or_constant_value_1__2_, Slice_wetland, Minus_wetland)

# Process: Weighted Sum
# Input: Slice_Slope, Slice_vege, Minus_stream, Minus_wetland
# Output: Weighte_composite
# Function: weight four criteria in different weight to get a composite weight
arcpy.gp.WeightedSum_sa("'Slice_Slope' VALUE 0.57;'CSlice_vege' VALUE 0.16;'Minus_stream' VALUE 0.2;'Minus_wetland' VALUE 0.07", Weighte_composite)

# Process: Times
# Input: Reclass_nelu_nowater, Weighte_composite
# Output: suitNat
# Function: Times the values after weighted and reclassified map
arcpy.gp.Times_sa(Reclass_nelu_nowater, Weighte_composite, suitNat)

# suitNat ends



# 1b starts
# precondition: all the input data should be raster data type
# postcondition: output raster may have a new range of values therefore maybe rendered slightly different
# Purpose: create a raster map which represents the highest availability pixel value among three perspectives, Agricuture, Development and Nature.
# Convert raster path string to raster type
sDevRas = arcpy.Raster("Dev_slice")
sNatRas = arcpy.Raster("SuitNat")
sAgrRas = arcpy.Raster("SuitSliceAgr")

# convert raster type to array type
Dev_sliceA = arcpy.RasterToNumPyArray(sDevRas)
suitNatA = arcpy.RasterToNumPyArray(sNatRas)
SuitSliceAgrA = arcpy.RasterToNumPyArray(sAgrRas)

nRows = SuitSliceAgrA.shape[0]
nCols = Dev_sliceA.shape[1]
nMean = SuitSliceAgrA.mean()
dMean = Dev_sliceA.mean()
nnMean = suitNatA.mean()
nStd = SuitSliceAgrA.std()

tmplist = []

for row in range(0, nRows):
    for col in range(0, nCols):
        suita = max(Dev_sliceA[row,col], suitNatA[row,col], SuitSliceAgrA[row,col]) # get the maximum value of three types of land uses, append to the list
        tmplist.append(suita)
        
newarray = numpy.asarray(tmplist)
newarray = newarray.reshape(nRows, nCols) # convert the array back to the raster type

#convert the resulting array back to a raster
future = arcpy.NumPyArrayToRaster(newarray, arcpy.Point(sNatRas.extent.XMin, sDevRas.extent.YMin), sNatRas.meanCellWidth, sNatRas.meanCellHeight)
# Input: EucDist_R2T_wetland
# Output: Slice_wetland
# Function: bsaed on equal interval method, slice the suitDev to 100 pieces.
#set the spatial reference to match the original raster
arcpy.DefineProjection_management(future, sNatRas)


future.save("Future1")
        

# Process: Reclassify (5)
# Input; value of nestream
# Output: Reclass_stream
# Function: reclassify nelu95 raster to avoid unavailable land
arcpy.gp.Reclassify_sa(nestream, "VALUE", "6 0;6 7 0;7 8 0;NODATA 1", Reclass_stream, "DATA")

# Process: Reclassify (3)
# Input; value of nelu95__2_
# Output: reclass_nelu95_avail
# Function: reclassify nelu95 raster to avoid unavailable land
arcpy.gp.Reclassify_sa(nelu95__2_, "VALUE", "111 194 0;194 429 1;429 625 0", reclass_nelu95_avail, "DATA")

# Process: Times
# Input: reclass_nelu95_avail, Reclass_stream
# Output: Times_nelu95_avastream
# Function: Times the values after weighted and reclassified map
arcpy.gp.Times_sa(reclass_nelu95_avail, Reclass_stream, Times_nelu95_avastream)

# Process: Reclassify
# Input; value of nelu95
# Output: Nelu_relassified
# Function: reclassify nelu95 raster to avoid unavailable land
arcpy.Reclassify_3d(nelu95, "VALUE", "111 200 1;200 300 2;300 625 3", Nelu_relassified, "DATA")


# Process: Over
# Input: future
# Output: Nelu_relassified
# Function: For the cell value of future is not 0, the output value will be future value. Where the cell values are 0,
#           the output will be that of Nelu_relassified.
arcpy.gp.Over_sa(future, Nelu_relassified, Over_futureland) 

# Process: Times (2)
# Input: Times_nelu95_avastream, Over_futureland
# Output: Times2
# Function: Times the values after weighted and reclassified map
arcpy.gp.Times_sa(Times_nelu95_avastream, Over_futureland, Times2)

# Process: Reclassify (4)
# Input; value of Times2
# Output: Reclass_Time2
# Function: reclassify nelu95 raster to avoid unavailable land
arcpy.Reclassify_3d(Times2, "VALUE", "0 NODATA;0 1 1;1 2 2;2 3 3", Reclass_Time2, "DATA")

# Process: Slice
# Input: Reclass_Time2
# Output: Slice_futureland
# Function: bsaed on equal area method, slice the suitDev to 100 pieces.
arcpy.Slice_3d(Reclass_Time2, Slice_futureland, "100", "EQUAL_AREA", "1")

# 1b process ends



# Process: conflict mapping
# Purpose: find the conflict area between two or three criterias using for loop structure
#          code integer 1 if at least two criterias' pixel value greater than their mean value
#          code integer 0 otherwise.
# precondition: input type must be a string represents the raster data path
#               rasters must remain the same spatial extent, same resolution, same number of rows and columns
# postcondition: output is a string path represents a new raster data file
tmplist2 = []

for r in range(0, nRows):
    for c in range(0, nCols):
        if ((Dev_sliceA[r,c] > dMean) and (suitNatA[r,c] > nnMean) and (SuitSliceAgrA[r,c] > nMean)):
            tmplist2.append(1) #three conflicts 
        elif ((Dev_sliceA[r,c] > dMean) and (suitNatA[r,c] > nnMean)):
            tmplist2.append(2) #Dev vs Nat conflict
        elif ((Dev_sliceA[r,c] > dMean) and (SuitSliceAgrA[r,c] > nMean)):
            tmplist2.append(3) #Dev vs Agr conflict
        elif ((suitNatA[r,c] > nnMean) and (SuitSliceAgrA[r,c] > nMean)):
            tmplist2.append(4) #Nat vs Agr
        else:
            tmplist2.append(5) #No conflict condition
        
newarray2 = numpy.asarray(tmplist2)
newarray2 = newarray2.reshape(nRows, nCols)

#convert the resulting array back to a raster
conflict = arcpy.NumPyArrayToRaster(newarray2, arcpy.Point(sNatRas.extent.XMin, sDevRas.extent.YMin), sNatRas.meanCellWidth, sNatRas.meanCellHeight)

#set the spatial reference to match the original raster
arcpy.DefineProjection_management(conflict, sNatRas)

conflict.save(r"conflicts")

# Process: Times
# Input: reclass_nelu95_avail, conflict
# Output: final_conflict
# Function: Times the values after weighted and reclassified map, get a 0 when conflict meets unavailable land
final_conflict = (r"final_conflict")
arcpy.gp.Times_sa(reclass_nelu95_avail, conflict, final_conflict)

# whole process ends


